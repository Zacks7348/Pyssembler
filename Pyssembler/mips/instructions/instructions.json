{
    "add": {
        "format": "add rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100000",
        "purpose": "Add 32 bit integers (trap on overflow)",
        "description": "GPR[rd] = GPR[rs] + GPR[rt]",
        "type": "R"
    },
    "addiu": {
        "format": "addiu rt, rs, immediate",
        "encoding": "001001{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "To add a constant to a 32-bit integer",
        "description": "GPR[rt] = GPR[rs] + immediate",
        "type": "I"
    },
    "addiupc": {
        "format": "addiupc rs, immediate",
        "encoding": "111011{rs:05b}00{imm:019b}",
        "purpose": "Add Immediate to PC (unsigned - non-trapping)",
        "description": "GPR[rs] = (PC + sign_extend(immediate << 2))",
        "type": "I"
    },
    "addu": {
        "format": "addu rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100001",
        "purpose": "To add 32-bit integers",
        "description": "GPR[rd] = GPR[rs] + GPR[rt]",
        "type": "R"
    },
    "align": {
        "format": "align rd, rs, rt, immediate",
        "encoding": "011111{rs:05b}{rt:05b}{rd:05b}010{imm:02b}100000",
        "purpose": "Concatenate two GPRs and extract a contiguous subset at a byte position",
        "description": "GPR[rd] = (GPR[rt] << (8*bp)) OR (GPR[rs] >> (32-8*bp))",
        "type": "R"
    },
    "aluipc": {
        "format": "aluipc rs, immediate",
        "encoding": "111011{rs:05b}11111{imm:016b}",
        "purpose": "Aligned Addition with upper immediate and PC",
        "description": "GPR[rs] = 0x0FFFF AND (PC + (immediate << 16))",
        "type": "I"
    },
    "and": {
        "format": "and rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100100",
        "purpose": "To do a bitwise logical AND",
        "description": "GPR[rd] = GPR[rs] AND GPR[rt]",
        "type": "R"
    },
    "andi": {
        "format": "andi rt, rs, immediate",
        "encoding": "001100{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "To do a bitwise logical AND with an immediate",
        "description": "GPR[rt] = GPR[rs] AND zero_extend(immediate)",
        "type": "I"
    },
    "aui": {
        "format": "aui rt, rs, immediate",
        "encoding": "001111{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Add upper immediate",
        "description": "GPR[rt] = GPR[rs] + (immediate << 16)",
        "type": "I"
    },
    "auipc": {
        "format": "auipc rs, immediate",
        "encoding": "111011{rs:05b}11110{imm:016b}",
        "purpose": "Add Upper Immediate to PC",
        "description": "GPR[rs] = PC + (immediate << 16)",
        "type": "I"
    },
    "bal": {
        "format": "bal immediate",
        "encoding": "0000010000010001{imm:016b}",
        "purpose": "To do an unconditional PC-relative procedure call",
        "description": "GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "balc": {
        "format": "balc immediate",
        "encoding": "111010{imm:026b}",
        "purpose": "To do an unconditional PC-relative procedure call (no delay slot)",
        "description": "GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bc": {
        "format": "bc immediate",
        "encoding": "110010{imm:026b}",
        "purpose": "Branch, Compact",
        "description": "PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "beq": {
        "format": "beq rs, rt, immediate",
        "encoding": "000100{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "To compare GPRs then do a PC-relative conditional branch",
        "description": "If GPR[rs] == GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "beqc": {
        "format": "beqc rs, rt, offset",
        "encoding": "001000{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Equal register-register compare and branch with 16-bit offset",
        "description": "If GPR[rs] == GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "beqzalc": {
        "format": "beqzalc rt, immediate",
        "encoding": "00100000000{rt:05b}{imm:016b}",
        "purpose": "Compact branch-and-link if GPR rt is equal to zero",
        "description": "If GPR[rt] == 0, GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "beqzc": {
        "format": "beqzc rs, immediate",
        "encoding": "110110{rs:05b}{imm:021b}",
        "purpose": "Branch if Equal to Zero Compact",
        "description": "If GPR[rt] == 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgec": {
        "format": "bgec rs, rt, immediate",
        "encoding": "010110{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch if Greater Than or Equal Compact (Signed)",
        "description": "If GPR[rs] >= GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgeuc": {
        "format": "bgeuc rs, rt, immediate",
        "encoding": "000110{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch if Greater Than or Equal Compact (Unsigned)",
        "description": "If GPR[rs] >= GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgez": {
        "format": "bgez rs, immediate",
        "encoding": "000001{rs:05b}00001{imm:016b}",
        "purpose": "Branch on Greater Than or Equal to Zero",
        "description": "If GPR[rs] >= 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgezalc": {
        "format": "bgezalc rt, immediate",
        "encoding": "000110{rt:05b}{rt:05b}{imm:016b}",
        "purpose": "Compact branch-and-link if GPR rt is greater than or equal to zero",
        "description": "If GPR[rt] >= 0, GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgezc": {
        "format": "bgezc rt, immediate",
        "encoding": "010110{rt:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch if Greater Than or Equal to Zero Compact",
        "description": "If GPR[rt] >= 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgtz": {
        "format": "bgtz rs, immediate",
        "encoding": "000111{rs:05b}00000{imm:016b}",
        "purpose": "Branch on Greater Than Zero",
        "description": "If GPR[rt] > 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgtzalc": {
        "format": "bgtzalc rt, immediate",
        "encoding": "00011100000{rt:05b}{imm:016b}",
        "purpose": "Compact branch-and-link if GPR rt is greater than zero",
        "description": "If GPR[rt] > 0, GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bgtzc": {
        "format": "bgtzc rt, immediate",
        "encoding": "01011100000{rt:05b}{imm:016b}",
        "purpose": "Branch if Greater Than Zero Compact",
        "description": "If GPR[rt] >= 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bitswap": {
        "format": "bitswap rd, rt",
        "encoding": "01111100000{rt:05b}{rd:05b}00000100000",
        "purpose": "Reverse bits in each byte",
        "description": "GPR[rd].byte(i) = reverse_bits(GPR[rt].byte(i)) for all bytes i",
        "type": "R"
    },
    "blez": {
        "format": "blez rs, immediate",
        "encoding": "000110{rs:05b}00000{imm:016b}",
        "purpose": "Branch on Less Than or Equal to Zero",
        "description": "If GPR[rt] <= 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "blezalc": {
        "format": "blezalc rt, immediate",
        "encoding": "00011000000{rt:05b}{imm:016b}",
        "purpose": "Compact branch-and-link if GPR rt is less than or equal to zero",
        "description": "If GPR[rt] <= 0, GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "blezc": {
        "format": "blezc rt, immediate",
        "encoding": "01011000000{rt:05b}{imm:016b}",
        "purpose": "Branch if Less Than or Equal to Zero Compact",
        "description": "If GPR[rt] <= 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bltc": {
        "format": "bltc rs, rt, immediate",
        "encoding": "010111{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch if Less Than Compact (Signed)",
        "description": "If GPR[rs] < GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bltuc": {
        "format": "bltuc rs, rt, immediate",
        "encoding": "000111{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch if Less Than Compact (Unsigned)",
        "description": "If GPR[rs] < GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bltz": {
        "format": "bltz rs, immediate",
        "encoding": "000001{rs:05b}00000{imm:016b}",
        "purpose": "Branch on Less than Zero",
        "description": "If GPR[rt] < 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bltzalc": {
        "format": "bltzalc rt, immediate",
        "encoding": "000111{rt:05b}{rt:05b}{imm:016b}",
        "purpose": "Compact branch-and-link if GPR rt is less than zero",
        "description": "If GPR[rt] < 0, GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bltzc": {
        "format": "bltzc rt, immediate",
        "encoding": "010111{rt:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch if Less Than Zero Compact",
        "description": "If GPR[rt] < 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bne": {
        "format": "bne rs, rt, immediate",
        "encoding": "000101{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch on Not Equal",
        "description": "If GPR[rs] != GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bnec": {
        "format": "bnec rs, rt, offset",
        "encoding": "011000{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Not-Equal register-register compare and branch with 16-bit offset",
        "description": "If GPR[rs] != GPR[rt], PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bnezalc": {
        "format": "bnezalc rt, immediate",
        "encoding": "01100000000{rt:05b}{imm:016b}",
        "purpose": "Compact branch-and-link if GPR rt is not equal to zero",
        "description": "If GPR[rt] != 0, GPR[31] = PC + 4, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bnezc": {
        "format": "bnezc rs, immediate",
        "encoding": "111110{rs:05b}{imm:021b}",
        "purpose": "Branch if Not Equal to Zero Compact",
        "description": "If GPR[rt] != 0, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bnvc": {
        "format": "bnvc rs, rt, immediate",
        "encoding": "011000{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch on no Overflow Compact",
        "description": "If GPR[rs] + GPR[rt] does not cause overflow, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "bovc": {
        "format": "bovc rs, rt, immediate",
        "encoding": "001000{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Branch on Overflow Compact",
        "description": "If GPR[rs] + GPR[rt] causes overflow, PC = (immediate << 2) + PC + 4",
        "type": "B"
    },
    "break": {
        "format": "break",
        "encoding": "00000000000000000000000000001101",
        "purpose": "Cause a breakpoint exception",
        "description": "PC is set to exception handler",
        "type": "R"
    },
    "clo": {
        "format": "clo rd, rs",
        "encoding": "000000{rs:05b}00000{rd:05b}00001010001",
        "purpose": "Count Leading Ones in Word",
        "description": "GPR[rd] = count_leading_ones(GPR[rs])",
        "type": "R"
    },
    "clz": {
        "format": "clz rd, rs",
        "encoding": "000000{rs:05b}00000{rd:05b}00001010000",
        "purpose": "Count Leading Zeroes in Word",
        "description": "GPR[rd] = count_leading_zeroes(GPR[rs])",
        "type": "R"
    },
    "div": {
        "format": "div rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00010011010",
        "purpose": "Divide 32 bit integers and save quotient (Signed)",
        "description": "GPR[rd] = GPR[rs] // GPR[rt]",
        "type": "R"
    },
    "divu": {
        "format": "divu rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00010011011",
        "purpose": "Divide 32 bit integers and save quotient",
        "description": "GPR[rd] = GPR[rs] // GPR[rt]",
        "type": "R"
    },
    "j": {
        "format": "j immediate",
        "encoding": "000010{imm:026b}",
        "purpose": "Jump to immediate address",
        "description": "PC = immediate << 2",
        "type": "JS"
    },
    "jal": {
        "format": "jal immediate",
        "encoding": "000011{imm:026b}",
        "purpose": "Jump and Link to immediate address",
        "description": "GPR[31] = PC + 4, PC = immediate << 2",
        "type": "JS"
    },
    "jalr": {
        "format": "jalr rd, rs",
        "encoding": "000000{rs:05b}00000{rd:05b}00000001001",
        "purpose": "Jump and Link to address in GPR[rs]",
        "description": "GPR[rd] = PC + 4, PC = GPR[rs]",
        "type": "J"
    },
    "jialc": {
        "format": "jialc rt, immediate",
        "encoding": "11111000000{rt:05b}{imm:016b}",
        "purpose": "Jump Indexed and Link Compact",
        "description": "GPR[31] = PC + 4, PC = GPR[rt] + immediate",
        "type": "J"
    },
    "jic": {
        "format": "jic rt, immediate",
        "encoding": "11011000000{rt:05b}{imm:016b}",
        "purpose": "Jump Indexed Compact",
        "description": "PC = GPR[rt] + immediate",
        "type": "J"
    },
    "lb": {
        "format": "lb rt, immediate(rs)",
        "encoding": "100000{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Load Byte from memory as signed value",
        "description": "GPR[rt] = MEM[GPR[rs] + immediate]",
        "type": "I"
    },
    "lbu": {
        "format": "lbu rt, immediate(rs)",
        "encoding": "100100{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Load Byte from memory as unsigned value",
        "description": "GPR[rt] = MEM[GPR[rs] + immediate]",
        "type": "I"
    },
    "lh": {
        "format": "lh rt, immediate(rs)",
        "encoding": "100001{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Load Halfword from memory as signed value",
        "description": "GPR[rt] = MEM[GPR[rs] + immediate]",
        "type": "I"
    },
    "lhu": {
        "format": "lhu rt, immediate(rs)",
        "encoding": "100101{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Load Halfword from memory as unsigned value",
        "description": "GPR[rt] = MEM[GPR[rs] + immediate]",
        "type": "I"
    },
    "lw": {
        "format": "lw rt, immediate(rs)",
        "encoding": "100011{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Load Word from memory as signed value",
        "description": "GPR[rt] = MEM[GPR[rs] + immediate]",
        "type": "I"
    },
    "lwpc": {
        "format": "lwpc rs, immediate",
        "encoding": "111011{rs:05b}01{imm:019b}",
        "purpose": "Load Word from memory as signed value using PC-relative address",
        "description": "GPR[rs] = MEM[PC + (immediate << 2)]",
        "type": "I"
    },
    "mfc0": {
        "format": "mfc0 rt, rd, sel",
        "encoding": "01000000000{rt:05b}{rd:05b}00000000{imm:03b}",
        "purpose": "Move from Coprocessor 0",
        "description": "GPR[rt] = CPR[0, rd, sel]",
        "type": "R"
    },
    "mod": {
        "format": "mod rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00011011010",
        "purpose": "Divide 32 bit integers and save remainder (Signed)",
        "description": "GPR[rd] = GPR[rs] % GPR[rt]",
        "type": "R"
    },
    "modu": {
        "format": "modu rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00011011011",
        "purpose": "Divide 32 bit integers and save remainder",
        "description": "GPR[rd] = GPR[rs] % GPR[rt]",
        "type": "R"
    },
    "mtc0": {
        "format": "mtc0 rt, rd, sel",
        "encoding": "01000000100{rt:05b}{rd:05b}00000000{imm:03b}",
        "purpose": "Move to Coprocessor 0",
        "description": "CPR[0, rd, sel] = GPR[rt]",
        "type": "R"
    },
    "muh": {
        "format": "muh rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00011011000",
        "purpose": "Multiply 32 bit integers and save high word (Signed)",
        "description": "GPR[rd] = GPR[rs] * GPR[rt]",
        "type": "R"
    },
    "muhu": {
        "format": "muhu rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00011011001",
        "purpose": "Multiply 32 bit integers and save low word",
        "description": "GPR[rd] = GPR[rs] * GPR[rt]",
        "type": "R"
    },
    "mul": {
        "format": "mul rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00010011000",
        "purpose": "Multiply 32 bit integers and save low word (Signed)",
        "description": "GPR[rd] = GPR[rs] * GPR[rt]",
        "type": "R"
    },
    "mulu": {
        "format": "mulu rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00010011001",
        "purpose": "Multiply 32 bit integers and save high word",
        "description": "GPR[rd] = GPR[rs] * GPR[rt]",
        "type": "R"
    },
    "nor": {
        "format": "nor rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100111",
        "purpose": "Bitwise logical NOT OR",
        "description": "GPR[rd] = GPR[rs] NOR GPR[rt]",
        "type": "R"
    },
    "or": {
        "format": "or rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100101",
        "purpose": "Bitwise logical OR",
        "description": "GPR[rd] = GPR[rs] OR GPR[rt]",
        "type": "R"
    },
    "ori": {
        "format": "ori rt, rs, immediate",
        "encoding": "001101{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Bitwise OR with immediate",
        "description": "GPR[rt] = GPR[rs] OR zero_extend(immediate)",
        "type": "I"
    },
    "sb": {
        "format": "sb rt, immediate(rs)",
        "encoding": "101000{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Store Byte in memory",
        "description": "MEM[GPR[rs] + immediate] = GPR[rt]",
        "type": "I"
    },
    "seb": {
        "format": "seb, rd, rt",
        "encoding": "01111100000{rt:05b}{rd:05b}10000100000",
        "purpose": "Sign-extend least significant byte",
        "description": "GPR[rd] = signextend(GPR[rt].byte(0))",
        "type": "R"
    },
    "seh": {
        "format": "seh, rd, rt",
        "encoding": "01111100000{rt:05b}{rd:05b}11000100000",
        "purpose": "Sign-extend least significant halfword",
        "description": "GPR[rd] = signextend(GPR[rt].half(0))",
        "type": "R"
    },
    "sh": {
        "format": "sh rt, immediate(rs)",
        "encoding": "101001{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Store Halfword in memory",
        "description": "MEM[GPR[rs] + immediate] = GPR[rt]",
        "type": "I"
    },
    "sll": {
        "format": "sll rt, rd, immediate",
        "encoding": "00000000000{rt:05b}{rd:05b}{imm:05b}000000",
        "purpose": "Shift Left Logical with immediate",
        "description": "GPR[rd] = GPR[rt] << immediate",
        "type": "R"
    },
    "sllv": {
        "format": "sllv rd, rt, rs",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000000100",
        "purpose": "Shift Left Logical Variable",
        "description": "GPR[rd] = GPR[rt] << GPR[rs]",
        "type": "R"
    },
    "slt": {
        "format": "slt rd, rt, rs",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000101010",
        "purpose": "Set on Less Than (Signed)",
        "description": "GPR[rd] = GPR[rs] < GPR[rt]",
        "type": "R"
    },
    "slti": {
        "format": "slti rt, rs, immediate",
        "encoding": "001010{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Set on Less Than Immediate (Signed)",
        "description": "GPR[rt] = GPR[rs] < sign_extend(immediate)",
        "type": "I"
    },
    "sltiu": {
        "format": "sltiu rt, rs, immediate",
        "encoding": "001011{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Set on Less Than Immediate (Unsigned)",
        "description": "GPR[rt] = GPR[rs] < sign_extend(immediate)",
        "type": "I"
    },
    "sltu": {
        "format": "sltu rd, rt, rs",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000101011",
        "purpose": "Set on Less Than",
        "description": "GPR[rd] = GPR[rs] < GPR[rt]",
        "type": "R"
    },
    "sra": {
        "format": "sra rd, rt, immediate",
        "encoding": "00000000000{rt:05b}{rd:05b}{imm:05b}000011",
        "purpose": "Shift Right Arithmetic (duplicate sign-bit)",
        "description": "GPR[rd] = GPR[rt] >> immediate",
        "type": "R"
    },
    "srav": {
        "format": "srav rd, rt, rs",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000000111",
        "purpose": "Shift Right Arithmetic Variable (duplicate sign-bit)",
        "description": "GPR[rd] = GPR[rt] >> GPR[rs]",
        "type": "R"
    },
    "srl": {
        "format": "srl rd, rt, immediate",
        "encoding": "00000000000{rt:05b}{rd:05b}{imm:05b}000010",
        "purpose": "Shift Right Logical (insert zeroes)",
        "description": "GPR[rd] = GPR[rt] >> immediate",
        "type": "R"
    },
    "srlv": {
        "format": "srlv rd, rt, rs",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000000110",
        "purpose": "Shift Right Logical Variable (insert zeroes)",
        "description": "GPR[rd] = GPR[rt] >> GPR[rs]",
        "type": "R"
    },
    "sub": {
        "format": "sub rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100010",
        "purpose": "Subtraction (trap on overflow)",
        "description": "GPR[rd] = GPR[rs] - GPR[rt]",
        "type": "R"
    },
    "subu": {
        "format": "subu rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100011",
        "purpose": "Subtraction",
        "description": "GPR[rd] = GPR[rs] - GPR[rt]",
        "type": "R"
    },
    "sw": {
        "format": "sw rt, immediate(rs)",
        "encoding": "101011{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Store Word in memory",
        "description": "MEM[GPR[rs] + immediate] = GPR[rt]",
        "type": "I"
    },
    "syscall": {
        "format": "syscall",
        "encoding": "00000000000000000000000000001100",
        "purpose": "Cause a System Call exception",
        "description": "",
        "type": "R"
    },
    "teq": {
        "format": "teq rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}0000000000110100",
        "purpose": "Trap if Equal",
        "description": "If GPR[rs] == GPR[rt], trap",
        "type": "R"
    },
    "tge": {
        "format": "tge rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}0000000000110000",
        "purpose": "Trap if Greater or Equal (Signed)",
        "description": "If GPR[rs] >= GPR[rt], trap",
        "type": "R"
    },
    "tgeu": {
        "format": "tgeu rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}0000000000110001",
        "purpose": "Trap if Greater or Equal",
        "description": "If GPR[rs] >= GPR[rt], trap",
        "type": "R"
    },
    "tlt": {
        "format": "tlt rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}0000000000110010",
        "purpose": "Trap if Less Than (Signed)",
        "description": "If GPR[rs] < GPR[rt], trap",
        "type": "R"
    },
    "tltu": {
        "format": "tltu rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}0000000000110011",
        "purpose": "Trap if Less Than",
        "description": "If GPR[rs] < GPR[rt], trap",
        "type": "R"
    },
    "tne": {
        "format": "tne rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}0000000000110110",
        "purpose": "Trap if Not Equal",
        "description": "If GPR[rs] != GPR[rt], trap",
        "type": "R"
    },
    "xor": {
        "format": "xor rd, rs, rt",
        "encoding": "000000{rs:05b}{rt:05b}{rd:05b}00000100110",
        "purpose": "Bitwise XOR",
        "description": "GPR[rd] = GPR[rs] XOR GPR[rt]",
        "type": "R"
    },
    "xori": {
        "format": "xori rt, rs, immediate",
        "encoding": "001110{rs:05b}{rt:05b}{imm:016b}",
        "purpose": "Bitwise Exclusive OR with Immediate",
        "description": "GPR[rt] = GPR[rs] XOR immediate",
        "type": "I"
    }
}